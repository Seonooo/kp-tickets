spring:
  application:
    name: queue-service

  # Virtual Threads 활성화 (Java 21 필수 기능)
  # 대규모 동시 접속 처리에 최적화
  threads:
    virtual:
      enabled: true

  data:
    redis:
      # Queue Redis (Active + Waiting Queue 통합)
      host: ${SPRING_REDIS_HOST:localhost}
      port: ${SPRING_REDIS_PORT:6379}
      password: ${SPRING_REDIS_PASSWORD:}
      timeout: ${SPRING_REDIS_TIMEOUT:3000}
      lettuce:
        pool:
          max-active: ${REDIS_POOL_MAX_ACTIVE:50}  # 대규모 트래픽 대응 (2GB heap 고려)
          max-idle: ${REDIS_POOL_MAX_IDLE:25}
          min-idle: ${REDIS_POOL_MIN_IDLE:10}
        cluster:
          refresh:
            adaptive: true
            period: 30s

  kafka:
    bootstrap-servers: ${SPRING_KAFKA_BOOTSTRAP_SERVERS:localhost:9092}
    consumer:
      group-id: ${KAFKA_CONSUMER_GROUP_ID:queue-service-group}
      auto-offset-reset: ${KAFKA_AUTO_OFFSET_RESET:earliest}
      key-deserializer: org.apache.kafka.common.serialization.StringDeserializer
      value-deserializer: org.apache.kafka.common.serialization.StringDeserializer
    producer:
      key-serializer: org.apache.kafka.common.serialization.StringSerializer
      value-serializer: org.apache.kafka.common.serialization.StringSerializer
      acks: ${KAFKA_PRODUCER_ACKS:all}
      retries: ${KAFKA_PRODUCER_RETRIES:3}

server:
  port: ${SERVER_PORT:8081}
  http2:
    enabled: true

# Queue 설정
queue:
  # 대기열 설정
  waiting:
    max-size: ${QUEUE_WAITING_MAX_SIZE:10000}  # 최대 대기 인원

  # 활성 대기열 설정
  active:
    max-size: ${QUEUE_ACTIVE_MAX_SIZE:50000}  # Phase 4: 현실적 크기로 복원 (순환 테스트용)
    token-ttl-seconds: ${QUEUE_ACTIVE_TOKEN_TTL:300}  # 토큰 유효시간 (5분)

  # 스케줄러 설정
  scheduler:
    activation-interval-ms: ${QUEUE_ACTIVATION_INTERVAL:1000}  # 활성화 주기 (1초) - 5배 빠름!
    cleanup-interval-ms: ${QUEUE_CLEANUP_INTERVAL:1000}  # 만료 토큰 정리 주기 (1초)

  # 폴링 설정
  polling:
    fast-interval-ms: ${QUEUE_POLLING_FAST_INTERVAL:3000}      # 빠른 폴링 간격 (3초)
    slow-interval-ms: ${QUEUE_POLLING_SLOW_INTERVAL:10000}     # 느린 폴링 간격 (10초)
    fast-threshold: ${QUEUE_POLLING_FAST_THRESHOLD:1000}       # 빠른 폴링 기준 순번
    min-interval-ms: ${QUEUE_POLLING_MIN_INTERVAL:2000}        # 클라이언트 권장 최소 폴링 간격 (2초)
    # Token Bucket Rate Limiting
    rate-limit-capacity: ${QUEUE_POLLING_RATE_LIMIT_CAPACITY:10}    # 버킷 최대 용량 (10개)
    rate-limit-refill-rate: ${QUEUE_POLLING_RATE_LIMIT_REFILL:0.5}  # 초당 리필 토큰 수 (0.5 = 2초당 1개)
    executor-pool-size: ${QUEUE_POLLING_EXECUTOR_POOL_SIZE:10}      # Virtual Thread Executor 풀 크기

  # 캐싱 설정 (Quick Win 최적화)
  cache:
    total-waiting-ttl-seconds: ${QUEUE_CACHE_TOTAL_WAITING_TTL:60}  # totalWaiting 캐시 TTL (60초)

# 스케줄러 락 설정 (헥사고날 Adapter 패턴)
scheduler:
  lock:
    strategy: ${SCHEDULER_LOCK_STRATEGY:cluster}  # none | cluster (Phase 2: 분산 환경)
    ttl-seconds: ${SCHEDULER_LOCK_TTL:30}         # 락 TTL (초)

# Kafka Topic 설정
kafka:
  topic:
    payment-completed: ${KAFKA_TOPIC_PAYMENT_COMPLETED:booking.payment.completed}

management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics,prometheus
      base-path: /actuator
  endpoint:
    health:
      show-details: ${ACTUATOR_HEALTH_SHOW_DETAILS:when_authorized}
      probes:
        enabled: true
  metrics:
    tags:
      # 인스턴스 식별 태그 (스케일 아웃 시 인스턴스별 메트릭 구분)
      instance: ${INSTANCE_ID:instance-1}
      service: queue-service
    distribution:
      percentiles-histogram:
        http.server.requests: true
    export:
      prometheus:
        enabled: true
  health:
    livenessState:
      enabled: true
    readinessState:
      enabled: true

logging:
  level:
    root: ${LOG_LEVEL_ROOT:INFO}
    personal.ai.queue: ${LOG_LEVEL_APP:DEBUG}
